package ostemplate

import (
	"bufio"
	"bytes"
	"context"
	"errors"
	"flag"
	"fmt"
	"io"
	"net"
	"os"
	"path/filepath"
	"strings"

	metalcloud "github.com/metalsoft-io/metal-cloud-sdk-go/v2"
	"github.com/metalsoft-io/tableformatter"
	"gopkg.in/yaml.v3"

	"github.com/go-git/go-billy/v5/memfs"
	git "github.com/go-git/go-git/v5"

	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/transport/http"
	diff "github.com/sergi/go-diff/diffmatchpatch"

	memory "github.com/go-git/go-git/v5/storage/memory"

	"github.com/kdomanski/iso9660"

	"github.com/bramvdbogaerde/go-scp"
	"github.com/bramvdbogaerde/go-scp/auth"
	"golang.org/x/crypto/ssh"

	kh "golang.org/x/crypto/ssh/knownhosts"

	"github.com/metalsoft-io/metalcloud-cli/internal/colors"
	"github.com/metalsoft-io/metalcloud-cli/internal/command"
	"github.com/metalsoft-io/metalcloud-cli/internal/configuration"
	"github.com/metalsoft-io/metalcloud-cli/internal/networking"
	"github.com/metalsoft-io/metalcloud-cli/internal/stringutils"

	"github.com/metalsoft-io/metalcloud-cli/pkg/osasset"
)

// Constants used with the deploy command
const templateFileName = "template.yaml"

const osArchitecture64 = "x86_64"

const bootMethodLocalDrives = "local_drives"
const bootMethodPxeIscsi = "pxe_iscsi"

const bootTypeUEFIOnly = "uefi_only"
const bootTypeLegacyOnly = "legacy_only"

const oobDeployProcess = "virtual_media"
const pxeDeployProcess = "pxe"

const assetTypeBootloader = "bootloader"
const assetTypeBootloaderConfig = "bootloader-config"
const assetTypeInstallerConfig = "installer-config"
const assetTypePatch = "patch"
const assetTypeOther = "other"

const assetMimeTypeDynamic = "text/plain"
const assetMimeTypeBinary = "application/octet-stream"

const assetTemplateTypeNone = "none"
const assetTemplateTypeSimple = "simple"
const assetTemplateTypeAdvanced = "advanced"

const assetUsageTypeBootloader = "bootloader"
const assetUsageTypeBuildComponent = "build_component"

const assetJSONTypeDynamic = "dynamic"
const assetJSONTypeBinary = "binary"

const nosSwitchRoleLeaf = "leaf"
const nosSwitchRoleSpine = "spine"
const nosSwitchRoleNone = "none"

const otherAssetsMaximumSizeBytes = 2097152

const localRepositoryName = "local"
const readMeFileName = "README.md"

const defaultImageRepositorySSHPath = "/home/repo/data/.iso"
const defaultImageRepositorySSHPort = "22"
const defaultImageRepositoryHostname = "repo.metalsoft.io"
const defaultImageRepositoryIsoPath = "/.iso"

type TemplateAsset struct {
	name         string
	contents     string
	Isopath      string `yaml:"isopath"`
	Mime         string `yaml:"mime"`
	TemplateType string `yaml:"template-type"`
	Usage        string `yaml:"usage"`
	Type         string `yaml:"type"`
	Url          string `yaml:"url"`
	Path         string `yaml:"path"`
}

type OsTemplateContents struct {
	BootType                        string `yaml:"boot-type"`
	BootMethodsSupported            string `yaml:"boot-methods-supported"`
	OsType                          string `yaml:"os-type"`
	OsVersion                       string `yaml:"os-version"`
	OsArchitecture                  string `yaml:"os-architecture"`
	NetworkOs                       bool   `yaml:"network-os"`
	NetworkOsArchitecture           string `yaml:"network-os-architecture"`
	NetworkOsVersion                string `yaml:"network-os-version"`
	NetworkOsDatacenterName         string `yaml:"network-os-datacenter-name"`
	NetworkOsVendor                 string `yaml:"network-os-vendor"`
	NetworkOsMachine                string `yaml:"network-os-machine"`
	NetworkOsSwitchDriver           string `yaml:"network-os-switch-driver"`
	NetworkOsSwitchRole             string `yaml:"network-os-switch-role"`
	OsReadyMethod                   string `yaml:"os-ready-method"`
	ImageBuildRequired              bool   `yaml:"image-build-required"`
	ProvisionViaOob                 bool   `yaml:"provision-via-oob"`
	InitialUser                     string `yaml:"initial-user"`
	InitialSSHPort                  int    `yaml:"initial-ssh-port"`
	UseAutogeneratedInitialPassword bool   `yaml:"use-autogenerated-initial-password"`
	InstallBootloaderAsset          string `yaml:"install-bootloader-asset"`
	OsBootBootloaderAsset           string `yaml:"os-boot-bootloader-asset"`
}

type TemplateContents struct {
	OsTemplateContents OsTemplateContents       `yaml:"os-template"`
	Assets             map[string]TemplateAsset `yaml:"assets"`
}

// Struct containing the values that will be printed out for a repo template
type RepoTemplate struct {
	Type                 string
	Version              string
	Architecture         string
	NosArchitecture      string
	NosVersion           string
	NosDatacenterName    string
	NosVendor            string
	NosMachine           string
	NosSwitchDriver      string
	NosSwitchRole        string
	DeployProcess        string
	BootType             string
	SourcePath           string
	TemplateFileContents string
	OsTemplateContents   OsTemplateContents
	Assets               map[string]TemplateAsset
	Errors               []string
}

// Struct containing assets that are to be created after all checks are done.
type Asset struct {
	Name     string
	Command  command.Command
	Contents string
}

var OsTemplatesCmds = []command.Command{
	{
		Description:  "Lists available templates.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list",
		AltPredicate: "ls",
		FlagSet:      flag.NewFlagSet("list templates", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"format": c.FlagSet.String("format", command.NilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
				"usage":  c.FlagSet.String("usage", command.NilDefaultStr, "Template's usage"),
			}
		},
		ExecuteFunc: templatesListCmd,
		Endpoint:    configuration.ExtendedEndpoint,
	},
	{
		Description:  "Create an empty template record.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "create",
		AltPredicate: "new",
		FlagSet:      flag.NewFlagSet("create template", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"label":                              c.FlagSet.String("label", command.NilDefaultStr, colors.Red("(Required)")+" Template's label"),
				"display_name":                       c.FlagSet.String("display-name", command.NilDefaultStr, colors.Red("(Required)")+" Template's display name"),
				"size":                               c.FlagSet.Int("size", command.NilDefaultInt, "Template's size (bytes)"),
				"boot_methods_supported":             c.FlagSet.String("boot-methods-supported", command.NilDefaultStr, colors.Red("(Required)")+" Template boot methods supported. Defaults to pxe_iscsi."),
				"os_bootstrap_function_name":         c.FlagSet.String("os-bootstrap-function-name", command.NilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
				"boot_type":                          c.FlagSet.String("boot-type", command.NilDefaultStr, colors.Red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
				"description":                        c.FlagSet.String("description", command.NilDefaultStr, "Template description"),
				"os_type":                            c.FlagSet.String("os-type", command.NilDefaultStr, colors.Red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
				"os_version":                         c.FlagSet.String("os-version", command.NilDefaultStr, colors.Red("(Required)")+" Template operating system version."),
				"os_architecture":                    c.FlagSet.String("os-architecture", command.NilDefaultStr, colors.Red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
				"initial_user":                       c.FlagSet.String("initial-user", command.NilDefaultStr, colors.Red("(Required)")+" Template's initial username, used to verify install."),
				"initial_password":                   c.FlagSet.String("initial-password", command.NilDefaultStr, colors.Red("(Required)")+" Template's initial password, used to verify install."),
				"use_autogenerated_initial_password": c.FlagSet.Bool("use-autogenerated-initial-password", false, colors.Green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used withinitial-password and initial-user params."),
				"initial_ssh_port":                   c.FlagSet.Int("initial-ssh-port", command.NilDefaultInt, colors.Red("(Required)")+" Template's initial ssh port, used to verify install."),
				"change_password_after_deploy":       c.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
				"image_build_required":               c.FlagSet.Bool("image-build-required", false, colors.Green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
				"provision_via_oob":                  c.FlagSet.Bool("provision-via-oob", false, colors.Green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
				"repo_url":                           c.FlagSet.String("repo-url", command.NilDefaultStr, "Template's location the repository"),
				"os_ready_method":                    c.FlagSet.String("os-ready-method", command.NilDefaultStr, "Possible values: 'wait_for_ssh', 'wait_for_signal_from_os'. Default value: 'wait_for_ssh'."),
				"os_asset_id_bootloader_local_install_id_or_name": c.FlagSet.String("install-bootloader-asset", command.NilDefaultStr, "Template's bootloader asset id during install"),
				"os_asset_id_bootloader_os_boot_id_or_name":       c.FlagSet.String("os-boot-bootloader-asset", command.NilDefaultStr, "Template's bootloader asset id during regular server boot"),
				"version":                    c.FlagSet.String("version", command.NilDefaultStr, "Template version. Default value is 0.0.0"),
				"network_os":                 c.FlagSet.Bool("network-os", false, colors.Green("(Flag)")+" Must be set for network operating system (NOS) templates."),
				"network_os_switch_driver":   c.FlagSet.String("network-os-switch-driver", command.NilDefaultStr, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) switch driver, e.g. 'sonic_enterprise'."),
				"network_os_switch_role":     c.FlagSet.String("network-os-switch-role", command.NilDefaultStr, colors.Yellow("(Flag)")+"Network operating system (NOS) switch role. Possible values: 'leaf', 'spine'."),
				"network_os_datacenter_name": c.FlagSet.String("network-os-datacenter-name", command.NilDefaultStr, colors.Yellow("(Flag)")+"Network operating system (NOS) datacenter name, e.g. 'dc1'"),
				"network_os_version":         c.FlagSet.String("network-os-version", command.NilDefaultStr, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) version, e.g. '4.0.2'"),
				"network_os_architecture":    c.FlagSet.String("network-os-architecture", command.NilDefaultStr, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) architecture. Possible values: 'x86_64', 'aarch64'."),
				"network_os_vendor":          c.FlagSet.String("network-os-vendor", command.NilDefaultStr, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) vendor, e.g. 'dellemc'"),
				"network_os_machine":         c.FlagSet.String("network-os-machine", command.NilDefaultStr, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) machine(equipment model) e.g.'s5212f_c3538'"),
				"return-id":                  c.FlagSet.Bool("return-id", false, colors.Green("(Flag)")+" If set will print the ID of the created infrastructure. Useful for automating tasks."),
			}
		},
		ExecuteFunc: templateCreateCmd,
		Endpoint:    configuration.ExtendedEndpoint,
	},
	{
		Description:  "Edit a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "update",
		AltPredicate: "edit",
		FlagSet:      flag.NewFlagSet("update template", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name":        c.FlagSet.String("id", command.NilDefaultStr, colors.Red("(Required)")+" Template's id or label"),
				"label":                      c.FlagSet.String("label", command.NilDefaultStr, colors.Red("(Required)")+" Template's label"),
				"display_name":               c.FlagSet.String("display-name", command.NilDefaultStr, colors.Red("(Required)")+" Template's display name"),
				"size":                       c.FlagSet.Int("size", command.NilDefaultInt, "Template's size (bytes)"),
				"boot_methods_supported":     c.FlagSet.String("boot-methods-supported", command.NilDefaultStr, "Template boot methods supported. Defaults to pxe_iscsi."),
				"os_bootstrap_function_name": c.FlagSet.String("os-bootstrap-function-name", command.NilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
				"boot_type":                  c.FlagSet.String("boot-type", command.NilDefaultStr, colors.Red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
				"description":                c.FlagSet.String("description", command.NilDefaultStr, "Template description"),
				"os_type":                    c.FlagSet.String("os-type", command.NilDefaultStr, colors.Red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
				"os_version":                 c.FlagSet.String("os-version", command.NilDefaultStr, colors.Red("(Required)")+" Template operating system version."),
				"os_architecture":            c.FlagSet.String("os-architecture", command.NilDefaultStr, colors.Red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
				"os_asset_id_bootloader_local_install_id_or_name": c.FlagSet.String("install-bootloader-asset", command.NilDefaultStr, "Template's bootloader asset id during install"),
				"os_asset_id_bootloader_os_boot_id_or_name":       c.FlagSet.String("os-boot-bootloader-asset", command.NilDefaultStr, "Template's bootloader asset id during regular server boot"),
				"initial_user":                       c.FlagSet.String("initial-user", command.NilDefaultStr, colors.Red("(Required)")+" Template's initial username, used to verify install."),
				"initial_password":                   c.FlagSet.String("initial-password", command.NilDefaultStr, colors.Red("(Required)")+" Template's initial password, used to verify install."),
				"use_autogenerated_initial_password": c.FlagSet.Bool("use-autogenerated-initial-password", false, colors.Green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used with --initial-password, requires --initial-user params."),
				"initial_ssh_port":                   c.FlagSet.Int("initial-ssh-port", command.NilDefaultInt, colors.Red("(Required)")+" Template's initial ssh port, used to verify install."),
				"os_ready_method":                    c.FlagSet.String("os-ready-method", command.NilDefaultStr, "Possible values: 'wait_for_ssh', 'wait_for_signal_from_os'. Default value: 'wait_for_ssh'."),
				"change_password_after_deploy":       c.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
				"image_build_required":               c.FlagSet.Bool("image-build-required", false, colors.Green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
				"provision_via_oob":                  c.FlagSet.Bool("provision-via-oob", false, colors.Green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
				"repo_url":                           c.FlagSet.String("repo-url", command.NilDefaultStr, "Template description"),
				"network_os":                         c.FlagSet.Bool("network-os", false, colors.Green("(Flag)")+" Must be set for network operating system (NOS) templates."),
				"network_os_switch_driver":           c.FlagSet.String("network-os-switch-driver", command.NilDefaultStr, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) switch driver, e.g. 'sonic_enterprise'."),
				"network_os_switch_role":             c.FlagSet.String("network-os-switch-role", command.NilDefaultStr, colors.Yellow("(Flag)")+"Network operating system (NOS) switch role. Possible values: 'leaf', 'spine'."),
				"network_os_datacenter_name":         c.FlagSet.String("network-os-datacenter-name", command.NilDefaultStr, colors.Yellow("(Flag)")+"Network operating system (NOS) datacenter name, e.g. 'dc1'"),
				"network_os_version":                 c.FlagSet.String("network-os-version", command.NilDefaultStr, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) version, e.g. '4.0.2'"),
				"network_os_architecture":            c.FlagSet.String("network-os-architecture", command.NilDefaultStr, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) architecture. Possible values: 'x86_64', 'aarch64'."),
				"network_os_vendor":                  c.FlagSet.String("network-os-vendor", command.NilDefaultStr, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) vendor, e.g. 'dellemc'"),
				"network_os_machine":                 c.FlagSet.String("network-os-machine", command.NilDefaultStr, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) machine(equipment model) e.g.'s5212f_c3538'"),
			}
		},
		ExecuteFunc: templateEditCmd,
		Endpoint:    configuration.ExtendedEndpoint,
	},
	{
		Description:  "Get details about a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "get",
		AltPredicate: "show",
		FlagSet:      flag.NewFlagSet("get template", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", command.NilDefaultStr, "Asset's id or name"),
				"format":              c.FlagSet.String("format", command.NilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
				"show_credentials":    c.FlagSet.Bool("show-credentials", false, colors.Green("(Flag)")+" If set returns the templates initial ssh credentials"),
			}
		},
		ExecuteFunc: templateGetCmd,
		Endpoint:    configuration.DeveloperEndpoint,
	},
	{
		Description:  "Delete a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "delete",
		AltPredicate: "rm",
		FlagSet:      flag.NewFlagSet("delete template", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", command.NilDefaultStr, "Asset's id or name"),
				"autoconfirm":         c.FlagSet.Bool("autoconfirm", false, colors.Green("(Flag)")+" If set it will assume action is confirmed"),
			}
		},
		ExecuteFunc: templateDeleteCmd,
		Endpoint:    configuration.ExtendedEndpoint,
	},
	{
		Description:  "Allow other users of the platform to use the OS template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "make-public",
		AltPredicate: "public",
		FlagSet:      flag.NewFlagSet("make template public", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", command.NilDefaultStr, "Template id or name"),
			}
		},
		ExecuteFunc: templateMakePublicCmd,
		Endpoint:    configuration.DeveloperEndpoint,
	},
	{
		Description:  "Stop other users of the platform from being able to use the OS template by allocating a specific owner.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "make-private",
		AltPredicate: "private",
		FlagSet:      flag.NewFlagSet("make template private", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", command.NilDefaultStr, "Template id or name"),
				"user_id":             c.FlagSet.String("user-id", command.NilDefaultStr, "New owner user id or email."),
			}
		},
		ExecuteFunc: templateMakePrivateCmd,
		Endpoint:    configuration.DeveloperEndpoint,
	},
	{
		Description:  "List associated assets.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list-assets",
		AltPredicate: "assoc",
		FlagSet:      flag.NewFlagSet("associated assets", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", command.NilDefaultStr, "Template's id or name"),
			}
		},
		ExecuteFunc: templateListAssociatedAssetsCmd,
		Endpoint:    configuration.ExtendedEndpoint,
	},
	{
		Description:  "Register a template from the template repository.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "register",
		AltPredicate: "build",
		FlagSet:      flag.NewFlagSet("register template from repo", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"name":            c.FlagSet.String("name", command.NilDefaultStr, colors.Red("(Required)")+"Name of the template."),
				"source-template": c.FlagSet.String("source-template", command.NilDefaultStr, colors.Red("(Required)")+"The source template to use as a base. It is either the source template path from a repository or a local path to a template.yaml file."),
				"source-iso":      c.FlagSet.String("source-iso", command.NilDefaultStr, colors.Yellow("(Required if 'provision-via-oob: true')")+"The local path for the source ISO image path."),
				"label":           c.FlagSet.String("label", command.NilDefaultStr, colors.Yellow("(Optional)")+"Label of the template. If not present, is the name of the template. Using a different label name on subsequent runs will create a new template."),
				"description":     c.FlagSet.String("description", command.NilDefaultStr, colors.Yellow("(Optional)")+"Description of the template."),
				"assets-update":   c.FlagSet.String("assets-update", command.NilDefaultStr, colors.Yellow("(Optional)")+"Assets that will have their contents replaced inside the template. Check examples for format."),
				"repo":            c.FlagSet.String("repo", command.NilDefaultStr, colors.Yellow("(Optional)")+"Override the default github url used to download template files for given OS."),
				// Add this parameter when ISO upload is allowed
				// "skip-upload-to-repo":      c.FlagSet.Bool("skip-upload-to-repo", false, colors.Yellow("(Optional)")+"Skip ISO image upload to the HTTP repository."),
				"skip-host-key-checking": c.FlagSet.Bool("skip-host-key-checking", true, colors.Yellow("(Optional)")+"Skip the manual check when adding a host key to the known_hosts file in the ISO image upload process."),
				"replace-if-exists":      c.FlagSet.Bool("replace-if-exists", false, colors.Yellow("(Optional)")+"Replaces ISO image if one already exists in the HTTP repository."),
				"debug":                  c.FlagSet.Bool("debug", false, colors.Green("(Flag)")+"If set, increases log level."),
				"return-id":              c.FlagSet.Bool("return-id", false, colors.Green("(Flag)")+"If set, returns the ID of the generated template. Useful for automation."),
			}
		},
		ExecuteFunc: templateRegisterCmd,
		Endpoint:    configuration.ExtendedEndpoint,
		Example: `
metalcloud-cli os-template register --name test-template --source-template Ubuntu/20.04/oob-uefi-boot --source-iso ubuntu-20.04.4-live-server-amd64.iso â€”-assets-update user-data:./replace_asset_1,vendor-data:./replace_asset_2
metalcloud-cli os-template register --name test-100 --source-template Ubuntu/20.04/oob-uefi-boot --source-iso ubuntu-20.04.4-live-server-amd64.iso --replace-if-exists --skip-host-key-checking=false
metalcloud-cli os-template register --name "SONiC Enterprise 4.0.2 - Spine" --source-template "SONiC/4.0.2/sonic-enterprise-premium-spine"
`,
	},
	{
		Description:  "Create a diff file.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "create-diff",
		AltPredicate: "diff",
		FlagSet:      flag.NewFlagSet("create the diff of 2 files", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"file1":       c.FlagSet.String("file1", command.NilDefaultStr, colors.Red("(Required)")+"Path of the first file."),
				"file2":       c.FlagSet.String("file2", command.NilDefaultStr, colors.Red("(Required)")+"Path of the second file."),
				"output-file": c.FlagSet.String("output-file", command.NilDefaultStr, colors.Red("(Required)")+"Path of the output file. This file must have Unix(LF) end of line encoding to be used as a patch file later."),
			}
		},
		ExecuteFunc: templateDiffCmd,
		Endpoint:    configuration.ExtendedEndpoint,
	},
	{
		Description:  "List OS source templates from a repository.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list-source-templates",
		AltPredicate: "source-templates",
		FlagSet:      flag.NewFlagSet("list OS source templates from a repository", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"repo":   c.FlagSet.String("repo", command.NilDefaultStr, colors.Yellow("(Optional)")+"Override the default github url used to download template files for given OS."),
				"format": c.FlagSet.String("format", command.NilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
			}
		},
		ExecuteFunc: templateListRepoCmd,
		Endpoint:    configuration.ExtendedEndpoint,
	},
	{
		Description:  "List the assets from an OS source template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list-source-template-assets",
		AltPredicate: "source-template-assets",
		FlagSet:      flag.NewFlagSet("list assets from an OS source template", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"repo":            c.FlagSet.String("repo", command.NilDefaultStr, colors.Yellow("(Optional)")+"Override the default github url used to download template files for given OS. If using a local template, use the keyword 'local'."),
				"source-template": c.FlagSet.String("source-template", command.NilDefaultStr, colors.Red("(Required)")+"The source template to use as a base. It's either the source path from a repository or a local path to the template.yaml file."),
				"format":          c.FlagSet.String("format", command.NilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
			}
		},
		ExecuteFunc: templateListAssetsCmd,
		Endpoint:    configuration.ExtendedEndpoint,
	},
	{
		Description:  "Validates OS source templates from a repository.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "validate-repo",
		AltPredicate: "validate-repo",
		FlagSet:      flag.NewFlagSet("validate OS source templates from a repository", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"repo": c.FlagSet.String("repo", command.NilDefaultStr, colors.Yellow("(Optional)")+"Override the default github url used to download template files for given OS."),
			}
		},
		ExecuteFunc: templateValidateRepoCmd,
		Endpoint:    configuration.ExtendedEndpoint,
	},
	{
		Description:  "Validates an OS source template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "validate-template",
		AltPredicate: "validate-template",
		FlagSet:      flag.NewFlagSet("validate an OS source templates", flag.ExitOnError),
		InitFunc: func(c *command.Command) {
			c.Arguments = map[string]interface{}{
				"repo":            c.FlagSet.String("repo", command.NilDefaultStr, colors.Yellow("(Optional)")+"Override the default github url used to download template files for given OS. If using a local template, use the keyword 'local'."),
				"source-template": c.FlagSet.String("source-template", command.NilDefaultStr, colors.Red("(Required)")+"The source template to use as a base. It's either the source path from a repository or a local path to the template.yaml file."),
			}
		},
		ExecuteFunc: templateValidateCmd,
		Endpoint:    configuration.ExtendedEndpoint,
	},
}

func templatesListCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {
	list, err := client.OSTemplates()

	if err != nil {
		return "", err
	}

	schema := []tableformatter.SchemaField{
		{
			FieldName: "ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 2,
		},
		{
			FieldName: "LABEL",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "NAME",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "DESCRIPTION",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "SIZE_MBYTES",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "BOOT_METHODS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "NOS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "INSTALL_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "USER_ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "CREATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "UPDATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}
	for _, s := range *list {

		installBootloader := ""
		if s.OSAssetBootloaderLocalInstall != 0 {
			asset, err := client.OSAssetGet(s.OSAssetBootloaderLocalInstall)
			if err != nil {
				return "", err
			}
			installBootloader = asset.OSAssetFileName
		}
		osBootloader := ""
		if s.OSAssetBootloaderOSBoot != 0 {
			asset, err := client.OSAssetGet(s.OSAssetBootloaderOSBoot)
			if err != nil {
				return "", err
			}
			osBootloader = asset.OSAssetFileName
		}

		osData := ""

		if s.VolumeTemplateOperatingSystem != nil {
			os := *s.VolumeTemplateOperatingSystem
			osData = fmt.Sprintf("%s %s %s",
				os.OperatingSystemType,
				os.OperatingSystemVersion,
				os.OperatingSystemArchitecture)
		}

		nosData := ""

		if s.VolumeTemplateNetworkOperatingSystem != nil {
			nos := *s.VolumeTemplateNetworkOperatingSystem
			nosData = fmt.Sprintf("%s %s %s %s %s %s %s",
				nos.OperatingSystemSwitchDriver,
				nos.OperatingSystemMachine,
				nos.OperatingSystemArchitecture,
				nos.OperatingSystemVersion,
				nos.OperatingSystemVendor,
				nos.OperatingSystemSwitchRole,
				nos.OperatingSystemDatacenterName)
		}

		data = append(data, []interface{}{
			s.VolumeTemplateID,
			s.VolumeTemplateLabel,
			s.VolumeTemplateDisplayName,
			s.VolumeTemplateDescription,
			s.VolumeTemplateSizeMBytes,
			s.VolumeTemplateBootMethodsSupported,
			osData,
			nosData,
			installBootloader,
			osBootloader,
			s.UserID,
			s.VolumeTemplateCreatedTimestamp,
			s.VolumeTemplateUpdatedTimestamp,
		})
	}

	tableformatter.TableSorter(schema).OrderBy(schema[0].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}
	return table.RenderTable("Templates", "", command.GetStringParam(c.Arguments["format"]))
}

func templateCreateCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {
	obj := metalcloud.OSTemplate{}
	updatedObj, err := updateTemplateFromCommand(obj, c, client, true)
	if err != nil {
		return "", err
	}

	ret, err := client.OSTemplateCreate(*updatedObj)
	if err != nil {
		return "", err
	}

	if command.GetBoolParam(c.Arguments["return-id"]) {
		return fmt.Sprintf("%d", ret.VolumeTemplateID), nil
	}

	return "", err
}

func templateEditCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {

	obj, err := command.GetOSTemplateFromCommand("id", c, client, false)
	if err != nil {
		return "", err
	}
	newobj := metalcloud.OSTemplate{}
	updatedObj, err := updateTemplateFromCommand(newobj, c, client, false)
	if err != nil {
		return "", err
	}

	_, err = client.OSTemplateUpdate(obj.VolumeTemplateID, *updatedObj)

	return "", err
}

func updateTemplateFromCommand(obj metalcloud.OSTemplate, c *command.Command, client metalcloud.MetalCloudClient, checkRequired bool) (*metalcloud.OSTemplate, error) {
	if v, ok := command.GetStringParamOk(c.Arguments["version"]); ok {
		obj.VolumeTemplateVersion = v
	}

	if v, ok := command.GetStringParamOk(c.Arguments["os_ready_method"]); ok {
		obj.VolumeTemplateOSReadyMethod = v
	}

	if v, ok := command.GetStringParamOk(c.Arguments["os_bootstrap_function_name"]); ok {
		obj.VolumeTemplateOsBootstrapFunctionName = v
	}

	if v, ok := command.GetStringParamOk(c.Arguments["label"]); ok {
		obj.VolumeTemplateLabel = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("label is required")
		}
	}

	if v, ok := command.GetStringParamOk(c.Arguments["display_name"]); ok {
		obj.VolumeTemplateDisplayName = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("display-name is required")
		}
	}

	if v, ok := command.GetIntParamOk(c.Arguments["size"]); ok {
		obj.VolumeTemplateSizeMBytes = v
	}

	obj.VolumeTemplateIsOSTemplate = true

	if v, ok := command.GetStringParamOk(c.Arguments["boot_methods_supported"]); ok {
		obj.VolumeTemplateBootMethodsSupported = v
	}

	if v, ok := command.GetStringParamOk(c.Arguments["boot_type"]); ok {
		obj.VolumeTemplateBootType = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("boot-type is required")
		}
	}

	if v, ok := command.GetStringParamOk(c.Arguments["description"]); ok {
		obj.VolumeTemplateDescription = v
	}

	if command.GetBoolParam(c.Arguments["network_os"]) {
		obj.VolumeTemplateIsForSwitch = true
	}

	if obj.VolumeTemplateIsForSwitch {
		//Network OS Data
		nos, err := command.GetNetworkOperatingSystemFromCommand(c)

		if err != nil {
			return nil, err
		} else if checkRequired && *nos == (metalcloud.NetworkOperatingSystem{}) {
			return nil, fmt.Errorf("network-os flags are required")
		}

		if *nos != (metalcloud.NetworkOperatingSystem{}) {
			obj.VolumeTemplateNetworkOperatingSystem = nos
		}
	} else {
		//OS Data
		os, err := command.GetOperatingSystemFromCommand(c)

		if err != nil {
			return nil, err
		} else if checkRequired && *os == (metalcloud.OperatingSystem{}) {
			return nil, fmt.Errorf("os flags are required")
		}
		if *os != (metalcloud.OperatingSystem{}) {
			obj.VolumeTemplateOperatingSystem = os
		}
	}

	// Boot options

	if _, ok := command.GetStringParamOk(c.Arguments["os_asset_id_bootloader_local_install_id_or_name"]); ok {
		localInstallAsset, err := command.GetOSAssetFromCommand("install_bootloader_asset", "os_asset_id_bootloader_local_install_id_or_name", c, client)
		if err != nil {
			return nil, err
		}
		obj.OSAssetBootloaderLocalInstall = localInstallAsset.OSAssetID
	}

	if _, ok := command.GetStringParamOk(c.Arguments["os_asset_id_bootloader_os_boot_id_or_name"]); ok {
		osBootBootloaderAsset, err := command.GetOSAssetFromCommand("os_boot_bootloader_asset", "os_asset_id_bootloader_os_boot_id_or_name", c, client)
		if err != nil {
			return nil, err
		}
		obj.OSAssetBootloaderOSBoot = osBootBootloaderAsset.OSAssetID
	}

	//Credentials

	creds, err := getCredentialsFromCommand(c, checkRequired)

	if err != nil {
		return nil, err
	}

	if *creds != (metalcloud.OSTemplateCredentials{}) {
		obj.OSTemplateCredentials = creds
	}

	if v, ok := command.GetStringParamOk(c.Arguments["repo_url"]); ok {
		obj.VolumeTemplateRepoURL = v
	}

	obj.VolumeTemplateImageBuildRequired = command.GetBoolParam(c.Arguments["image_build_required"])
	obj.VolumeTemplateProvisionViaOOB = command.GetBoolParam(c.Arguments["provision_via_oob"])

	return &obj, nil
}

func getCredentialsFromCommand(c *command.Command, checkRequired bool) (*metalcloud.OSTemplateCredentials, error) {
	var creds = metalcloud.OSTemplateCredentials{}

	if command.GetBoolParam(c.Arguments["use_autogenerated_initial_password"]) {

		creds.OSTemplateUseAutogeneratedInitialPassword = true

		if _, ok := command.GetStringParamOk(c.Arguments["initial_password"]); ok {
			return nil, fmt.Errorf("--initial-password cannot be used with --use-autogenerated-initial-password")
		}

	} else {

		if v, ok := command.GetStringParamOk(c.Arguments["initial_password"]); ok {
			creds.OSTemplateInitialPassword = v
		} else {
			if checkRequired {
				return nil, fmt.Errorf("either --initial-password or --use-autogenerated-initial-password is required")
			}
		}
	}

	if v, ok := command.GetStringParamOk(c.Arguments["initial_user"]); ok {

		creds.OSTemplateInitialUser = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("initial-user is required")
		}
	}

	if v, ok := command.GetIntParamOk(c.Arguments["initial_ssh_port"]); ok {
		creds.OSTemplateInitialSSHPort = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("initial-ssh-port is required")
		}
	}

	creds.OSTemplateChangePasswordAfterDeploy = command.GetBoolParam(c.Arguments["change_password_after_deploy"])

	return &creds, nil
}

func templateDeleteCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {

	retS, err := command.GetOSTemplateFromCommand("id", c, client, false)
	if err != nil {
		return "", err
	}
	confirm := false

	if command.GetBoolParam(c.Arguments["autoconfirm"]) {
		confirm = true
	} else {

		confirmationMessage := fmt.Sprintf("Deleting template %s (%d).  Are you sure? Type \"yes\" to continue:",
			retS.VolumeTemplateDisplayName,
			retS.VolumeTemplateID)

		//this is simply so that we don't output a text on the command line under go test
		if strings.HasSuffix(os.Args[0], ".test") {
			confirmationMessage = ""
		}

		confirm, err = command.RequestConfirmation(confirmationMessage)
		if err != nil {
			return "", err
		}

	}

	if !confirm {
		return "", fmt.Errorf("Operation not confirmed. Aborting")
	}

	err = client.OSTemplateDelete(retS.VolumeTemplateID)

	return "", err
}

func templateGetCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {

	showCredentials := false
	if c.Arguments["show_credentials"] != nil && *c.Arguments["show_credentials"].(*bool) {
		showCredentials = true
	}

	template, err := command.GetOSTemplateFromCommand("id", c, client, showCredentials)
	if err != nil {
		return "", err
	}

	if err != nil {
		return "", err
	}

	schema := []tableformatter.SchemaField{
		{
			FieldName: "ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 2,
		},
		{
			FieldName: "LABEL",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "NAME",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "DESCRIPTION",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "SIZE_MBYTES",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "BOOT_METHODS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "NOS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "USER_ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "INSTALL_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "CREATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "UPDATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}

	credentials := ""

	if showCredentials && template.OSTemplateCredentials != nil {

		schema = append(schema, tableformatter.SchemaField{
			FieldName: "CREDENTIALS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		})

		credentials = fmt.Sprintf("user:%s (port %d) passwd:%s (change_password_after_install:%v)",
			template.OSTemplateCredentials.OSTemplateInitialUser,
			template.OSTemplateCredentials.OSTemplateInitialSSHPort,
			template.OSTemplateCredentials.OSTemplateInitialPassword,
			template.OSTemplateCredentials.OSTemplateChangePasswordAfterDeploy)

	}
	osDetails := ""

	if template.VolumeTemplateOperatingSystem != nil {
		os := *template.VolumeTemplateOperatingSystem
		osDetails = fmt.Sprintf("%s %s %s",
			os.OperatingSystemType,
			os.OperatingSystemVersion,
			os.OperatingSystemArchitecture)
	}

	nosDetails := ""

	if template.VolumeTemplateNetworkOperatingSystem != nil {
		nos := *template.VolumeTemplateNetworkOperatingSystem
		nosDetails = fmt.Sprintf("%s %s %s %s %s %s %s",
			nos.OperatingSystemSwitchDriver,
			nos.OperatingSystemMachine,
			nos.OperatingSystemArchitecture,
			nos.OperatingSystemVersion,
			nos.OperatingSystemVendor,
			nos.OperatingSystemSwitchRole,
			nos.OperatingSystemDatacenterName)
	}

	installBootloader := ""
	if template.OSAssetBootloaderLocalInstall != 0 {
		asset, err := client.OSAssetGet(template.OSAssetBootloaderLocalInstall)
		if err != nil {
			return "", err
		}
		installBootloader = asset.OSAssetFileName
	}
	osBootloader := ""
	if template.OSAssetBootloaderOSBoot != 0 {
		asset, err := client.OSAssetGet(template.OSAssetBootloaderOSBoot)
		if err != nil {
			return "", err
		}
		osBootloader = asset.OSAssetFileName
	}

	data = append(data, []interface{}{
		template.VolumeTemplateID,
		template.VolumeTemplateLabel,
		template.VolumeTemplateDisplayName,
		template.VolumeTemplateDescription,
		template.VolumeTemplateSizeMBytes,
		template.VolumeTemplateBootMethodsSupported,
		osDetails,
		nosDetails,
		template.UserID,
		installBootloader,
		osBootloader,
		template.VolumeTemplateCreatedTimestamp,
		template.VolumeTemplateUpdatedTimestamp,
		credentials,
	})

	topLine := fmt.Sprintf("Template %s (%d)\n", template.VolumeTemplateLabel, template.VolumeTemplateID)

	tableformatter.TableSorter(schema).OrderBy(
		schema[0].FieldName,
		schema[1].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}
	return table.RenderTable("Templates", topLine, command.GetStringParam(c.Arguments["format"]))
}

func templateMakePublicCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {
	template, err := command.GetOSTemplateFromCommand("id", c, client, false)

	if err != nil {
		return "", err
	}

	err = client.OSTemplateMakePublic(template.VolumeTemplateID)

	if err != nil {
		return "", err
	}

	return "", nil
}

func templateMakePrivateCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {
	template, err := command.GetOSTemplateFromCommand("id", c, client, false)

	if err != nil {
		return "", err
	}

	user, err := command.GetUserFromCommand("user-id", c, client)

	if err != nil {
		return "", err
	}

	if err = client.OSTemplateMakePrivate(template.VolumeTemplateID, user.UserID); err != nil {
		return "", err
	}

	return "", nil
}

func templateListAssociatedAssetsCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {
	ret, err := command.GetOSTemplateFromCommand("id", c, client, false)
	if err != nil {
		return "", err
	}

	list, err := client.OSTemplateOSAssets(ret.VolumeTemplateID)

	if err != nil {
		return "", err
	}

	schema := []tableformatter.SchemaField{
		{
			FieldName: "PATH",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 2,
		},
		{
			FieldName: "FILENAME",
			FieldType: tableformatter.TypeString,
			FieldSize: 20,
		},
		{
			FieldName: "FILE_SIZE_BYTES",
			FieldType: tableformatter.TypeInt,
			FieldSize: 4,
		},
		{
			FieldName: "FILE_MIME",
			FieldType: tableformatter.TypeString,
			FieldSize: 20,
		},
		{
			FieldName: "TEMPLATE_TYPE",
			FieldType: tableformatter.TypeString,
			FieldSize: 14,
		},
		{
			FieldName: "USAGE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "SOURCE_URL",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "VARIABLES_JSON",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}
	for path, s := range *list {

		data = append(data, []interface{}{
			path,
			s.OSAsset.OSAssetID,
			s.OSAsset.OSAssetFileName,
			s.OSAsset.OSAssetFileSizeBytes,
			s.OSAsset.OSAssetFileMime,
			s.OSAsset.OSAssetTemplateType,
			s.OSAsset.OSAssetUsage,
			s.OSAsset.OSAssetSourceURL,
			s.OSTemplateOSAssetVariablesJSON,
		})

	}

	tableformatter.TableSorter(schema).OrderBy(
		schema[0].FieldName,
		schema[1].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}
	return table.RenderTable("Associated assets", "", command.GetStringParam(c.Arguments["format"]))
}

func templateRegisterCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {
	var sourceTemplate string

	if sourceTemplateValue, ok := command.GetStringParamOk(c.Arguments["source-template"]); !ok {
		return "", fmt.Errorf("The 'source-template' parameter must be specified when using the 'register' command.")
	} else {
		sourceTemplate = sourceTemplateValue
	}

	useLocalTemplate := false

	if repoValue, ok := command.GetStringParamOk(c.Arguments["repo"]); ok {
		if repoValue == localRepositoryName {
			useLocalTemplate = true
		}
	}

	var repoTemplate RepoTemplate

	if !useLocalTemplate {
		repoMap := make(map[string]RepoTemplate)
		err := retrieveRepositoryAssets(c, repoMap)

		if err != nil {
			return "", err
		}

		if _, ok := repoMap[sourceTemplate]; !ok {
			return "", fmt.Errorf("Did not find source template '%s' in the repository.", sourceTemplate)
		}

		repoTemplate = repoMap[sourceTemplate]
	} else {
		fmt.Printf("Did not find source template '%s' in the repository, checking for local file.\n", sourceTemplate)

		_, err := os.ReadFile(sourceTemplate)

		if err != nil {
			return "", fmt.Errorf("Template file not found at path %s.", sourceTemplate)
		}

		getLocalTemplateAssets(filepath.Dir(sourceTemplate), &repoTemplate)
		_, err = populateTemplateValues(&repoTemplate)

		if err != nil {
			return "", err
		}
	}

	if len(repoTemplate.Errors) != 0 {
		fmt.Printf("Detected the following errors regarding template structure for template %s:\n", sourceTemplate)
	} else {
		fmt.Printf("Detected no errors for the given template.\n")
	}

	for _, errorMessage := range repoTemplate.Errors {
		fmt.Println("\t" + errorMessage)
	}

	if len(repoTemplate.Errors) != 0 {
		return "", fmt.Errorf("Aborting build due to errors regarding the source template.\n")
	}

	templateLabel, err := handleTemplateBuild(c, client, repoTemplate)

	if err != nil {
		return "", err
	}

	var templateID int
	var template metalcloud.OSTemplate

	list, err := client.OSTemplates()

	if err != nil {
		return "", err
	}

	for _, s := range *list {
		if s.VolumeTemplateLabel == templateLabel {
			template = s
			templateID = s.VolumeTemplateID
			break
		}
	}

	if !repoTemplate.OsTemplateContents.ProvisionViaOob {
		if repoTemplate.OsTemplateContents.InstallBootloaderAsset != "" || repoTemplate.OsTemplateContents.OsBootBootloaderAsset != "" {
			list, err := client.OSTemplateOSAssets(templateID)

			if err != nil {
				return "", err
			}

			for _, a := range *list {
				if a.OSAsset.OSAssetFileName == repoTemplate.OsTemplateContents.InstallBootloaderAsset {
					template.OSAssetBootloaderLocalInstall = a.OSAsset.OSAssetID
				} else if a.OSAsset.OSAssetFileName == repoTemplate.OsTemplateContents.OsBootBootloaderAsset {
					template.OSAssetBootloaderOSBoot = a.OSAsset.OSAssetID
				}
			}
			_, err = client.OSTemplateUpdate(templateID, template)

			if err != nil {
				return "", err
			}
		}
	}

	if err != nil {
		return "", fmt.Errorf("Failed to create template. Received error: %s", err)
	} else {
		fmt.Println("Done.")
	}

	if command.GetBoolParam(c.Arguments["return-id"]) {
		return fmt.Sprintf("%d", templateID), nil
	}

	return "", nil
}

func retrieveRepositoryAssets(c *command.Command, repoMap map[string]RepoTemplate) error {
	cloneOptions := new(git.CloneOptions)
	cloneOptions.Depth = 1 // We are only interested in the last commit

	if repositoryName, ok := command.GetStringParamOk(c.Arguments["repo"]); ok {
		var username, password string

		if userPrivateUsername := os.Getenv("METALCLOUD_USER_PRIVATE_REPOSITORY_USERNAME"); userPrivateUsername != "" {
			username = userPrivateUsername
		}

		if userPrivateToken := os.Getenv("METALCLOUD_USER_PRIVATE_REPOSITORY_TOKEN"); userPrivateToken != "" {
			password = userPrivateToken
		}

		cloneOptions.Auth = &http.BasicAuth{
			Username: username,
			Password: password,
		}

		cloneOptions.URL = repositoryName
	} else {
		// The default repository that is used if the user doesn't specify another one
		cloneOptions.URL = "https://github.com/metalsoft-io/os-templates.git"
	}

	// Filesystem abstraction based on memory
	fs := memfs.New()

	// Git objects storer based on memory
	storer := memory.NewStorage()

	// Clones the repository into the worktree (fs) and storer all the .git
	// content into the storer
	repo, err := git.Clone(storer, fs, cloneOptions)

	if err != nil {
		if err.Error() == "authentication required" {
			return fmt.Errorf("Failed to authenticate to the given repository. Please check if the repository exists and/or the given username is valid in the METALCLOUD_USER_PRIVATE_REPOSITORY_USERNAME environment variable and the given access token is valid in the METALCLOUD_USER_PRIVATE_REPOSITORY_TOKEN environment variable.")
		}

		return err
	}

	// Retrieve the HEAD reference
	ref, err := repo.Head()

	if err != nil {
		return err
	}

	commit, err := repo.CommitObject(ref.Hash())

	if err != nil {
		return err
	}

	tree, err := commit.Tree()

	if err != nil {
		return err
	}

	// This map stores all files for a template and will be used to check if their information is correct
	repoAssetsPerTemplate := make(map[string][]TemplateAsset)

	getRepositoryTemplateAssets(tree, repoMap, repoAssetsPerTemplate)
	repoHasErrors := false

	for templatePrefix, repoTemplate := range repoMap {
		repoTemplate.Assets = make(map[string]TemplateAsset)
		for _, asset := range repoAssetsPerTemplate[templatePrefix] {
			repoTemplate.Assets[asset.name] = asset
		}

		repoHasErrors, err = populateTemplateValues(&repoTemplate)

		if err != nil {
			return err
		}

		repoMap[templatePrefix] = repoTemplate
	}

	if repoHasErrors {
		fmt.Printf("Found errors for repository %s! Use the 'validate-repo' function to see them and fix them.\n", cloneOptions.URL)
	}

	return nil
}

func createRepositoryTemplatesTable(repoMap map[string]RepoTemplate) tableformatter.Table {
	schema := []tableformatter.SchemaField{
		{
			FieldName: "TYPE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "VERSION",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "ARCHITECTURE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "DEPLOY PROCESS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "BOOT TYPE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "SOURCE TEMPLATE PATH",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}
	for tableTemplatePreffix, repoTemplate := range repoMap {
		var tableType, tableArchitecture, tableDeployProcess, tableBootType, tableVersion string

		if repoTemplate.OsTemplateContents.NetworkOs {

			tableType = repoTemplate.NosMachine

			switch repoTemplate.NosArchitecture {
			case osArchitecture64:
				tableArchitecture = "x64"
			}

			if repoTemplate.NosVersion == "" {
				tableVersion = colors.Red("unknown")
			} else {
				tableVersion = repoTemplate.NosVersion
			}
		} else {
			tableType = repoTemplate.Type
			switch repoTemplate.Architecture {
			case osArchitecture64:
				tableArchitecture = "x64"
			default:
				tableArchitecture = colors.Red("unknown")
			}

			if repoTemplate.Version == "" {
				tableVersion = colors.Red("unknown")
			} else {
				tableVersion = repoTemplate.Version
			}
		}

		if repoTemplate.OsTemplateContents.ProvisionViaOob {
			tableDeployProcess = oobDeployProcess
		} else {
			tableDeployProcess = pxeDeployProcess
		}

		switch repoTemplate.BootType {
		case bootTypeUEFIOnly:
			tableBootType = "UEFI"
		case bootTypeLegacyOnly:
			tableBootType = "Legacy"
		default:
			tableBootType = colors.Red("unknown")
		}

		data = append(data, []interface{}{
			tableType,
			tableVersion,
			tableArchitecture,
			tableDeployProcess,
			tableBootType,
			tableTemplatePreffix,
		})

	}

	tableformatter.TableSorter(schema).OrderBy(schema[0].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}

	return table
}

func createTemplateAssetsTable(repoTemplate RepoTemplate) tableformatter.Table {
	schema := []tableformatter.SchemaField{
		{
			FieldName: "ASSET NAME",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "ISO_PATH",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "MIME",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "USAGE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "TYPE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "URL",
			FieldType: tableformatter.TypeString,
			FieldSize: 10,
		},
		{
			FieldName: "PATH",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}
	for _, asset := range repoTemplate.Assets {
		data = append(data, []interface{}{
			asset.name,
			asset.Isopath,
			asset.Mime,
			asset.Usage,
			asset.Type,
			asset.Url,
			asset.Path,
		})

	}

	tableformatter.TableSorter(schema).OrderBy(schema[0].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}

	return table
}

func handleTemplateBuild(c *command.Command, client metalcloud.MetalCloudClient, repoTemplate RepoTemplate) (string, error) {
	if templateName, ok := command.GetStringParamOk(c.Arguments["name"]); ok {
		// ISO images are required only for the OOB templates and the patch files are only applied to the bootloader file retrieved from the ISO image.
		err := checkOOBTemplateIntegrity(c, repoTemplate)

		if err != nil {
			return "", err
		}

		templateLabel, err := createTemplateAssets(c, client, repoTemplate, templateName)

		if err != nil {
			return "", err
		}

		return templateLabel, nil
	} else {
		return "", fmt.Errorf("The 'name' parameter must be specified when using the 'build' command.")
	}
}

func checkOOBTemplateIntegrity(c *command.Command, repoTemplate RepoTemplate) error {
	if !repoTemplate.OsTemplateContents.ProvisionViaOob {
		return nil
	}

	var imagePath string

	if sourceISO, ok := command.GetStringParamOk(c.Arguments["source-iso"]); ok {
		imagePath = sourceISO
	} else {
		return fmt.Errorf("The 'source-iso' parameter must be specified with the 'name' and 'source-template' ones for OOB templates.")
	}

	if !networking.CheckValidUrl(imagePath) {
		file, err := os.Open(imagePath)

		if err != nil {
			return fmt.Errorf("Image not found at path %s.", imagePath)
		}
		defer file.Close()

		image, err := iso9660.OpenImage(file)

		if err != nil {
			return err
		}
		rootDir, err := image.RootDir()

		if err != nil {
			return err
		}

		children, err := rootDir.GetChildren()

		if err != nil {
			return err
		}

		var bootloaderFile *iso9660.File = nil

		for _, asset := range repoTemplate.Assets {
			if asset.Type != assetTypePatch {
				continue
			}

			for _, child := range children {
				if !child.IsDir() && child.Name() == asset.name {
					bootloaderFile = child
					break
				}
			}

			if bootloaderFile == nil {
				return fmt.Errorf("Could not apply patch asset as the bootloader config file with name '%s' was not found in the given ISO image.", asset.name)
			}

			bootloaderData, err := io.ReadAll(bootloaderFile.Reader())

			if err != nil {
				return err
			}

			patchFileStringContents := asset.contents

			diffMatchPatch := diff.New()

			patches, err := diffMatchPatch.PatchFromText(patchFileStringContents)

			if err != nil {
				return fmt.Errorf("Failed to apply patch for asset %s. Make sure the file has a Unix (LF) End Of Line sequence.", asset.name)
			}

			patchedText, _ := diffMatchPatch.PatchApply(patches, string(bootloaderData))

			//Remove tabs and blank lines, somehow they get added when applying the patch
			patchedText = strings.ReplaceAll(patchedText, "\t", "")
			patchedText = strings.TrimSpace(patchedText)
			asset.contents = string(patchedText)

			repoTemplate.Assets[asset.name] = asset
		}
	}

	return nil
}

func createTemplateAssets(c *command.Command, client metalcloud.MetalCloudClient, repoTemplate RepoTemplate, templateName string) (string, error) {
	OsTemplateContents := repoTemplate.OsTemplateContents

	createTemplateCommand := command.Command{
		Description:  "Create a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "create",
		AltPredicate: "new",
		FlagSet:      flag.NewFlagSet("create template", flag.ExitOnError),
		ExecuteFunc:  templateCreateCmd,
		Endpoint:     configuration.ExtendedEndpoint,
	}

	templateLabel, err := stringutils.MakeLabel(templateName)
	if err != nil {
		return "", err
	}

	templateDescription := command.NilDefaultStr

	if label, ok := command.GetStringParamOk(c.Arguments["label"]); ok {
		templateLabel = label
	}

	if description, ok := command.GetStringParamOk(c.Arguments["description"]); ok {
		templateDescription = description
	}

	createTemplateCommand.Arguments = map[string]interface{}{
		"label":                              createTemplateCommand.FlagSet.String("label", templateLabel, colors.Red("(Required)")+" Template's label"),
		"display_name":                       createTemplateCommand.FlagSet.String("display-name", templateName, colors.Red("(Required)")+" Template's display name"),
		"size":                               createTemplateCommand.FlagSet.Int("size", command.NilDefaultInt, "Template's size (bytes)"),
		"boot_methods_supported":             createTemplateCommand.FlagSet.String("boot-methods-supported", OsTemplateContents.BootMethodsSupported, colors.Red("(Required)")+" Template boot methods supported. Defaults to pxe_iscsi."),
		"os_bootstrap_function_name":         createTemplateCommand.FlagSet.String("os-bootstrap-function-name", command.NilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
		"boot_type":                          createTemplateCommand.FlagSet.String("boot-type", OsTemplateContents.BootType, colors.Red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
		"description":                        createTemplateCommand.FlagSet.String("description", templateDescription, "Template description"),
		"os_type":                            createTemplateCommand.FlagSet.String("os-type", repoTemplate.Type, colors.Red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
		"os_version":                         createTemplateCommand.FlagSet.String("os-version", repoTemplate.Version, colors.Red("(Required)")+" Template operating system version."),
		"os_architecture":                    createTemplateCommand.FlagSet.String("os-architecture", repoTemplate.Architecture, colors.Red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
		"initial_user":                       createTemplateCommand.FlagSet.String("initial-user", OsTemplateContents.InitialUser, colors.Red("(Required)")+" Template's initial username, used to verify install."),
		"initial_password":                   createTemplateCommand.FlagSet.String("initial-password", command.NilDefaultStr, colors.Red("(Required)")+" Template's initial password, used to verify install."),
		"use_autogenerated_initial_password": createTemplateCommand.FlagSet.Bool("use-autogenerated-initial-password", OsTemplateContents.UseAutogeneratedInitialPassword, colors.Green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used withinitial-password and initial-user params."),
		"initial_ssh_port":                   createTemplateCommand.FlagSet.Int("initial-ssh-port", OsTemplateContents.InitialSSHPort, colors.Red("(Required)")+" Template's initial ssh port, used to verify install."),
		"change_password_after_deploy":       createTemplateCommand.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
		"image_build_required":               createTemplateCommand.FlagSet.Bool("image-build-required", OsTemplateContents.ImageBuildRequired, colors.Green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
		"provision_via_oob":                  createTemplateCommand.FlagSet.Bool("provision-via-oob", OsTemplateContents.ProvisionViaOob, colors.Green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
		"repo_url":                           createTemplateCommand.FlagSet.String("repo-url", command.NilDefaultStr, "Template's location the repository"),
		"os_ready_method":                    createTemplateCommand.FlagSet.String("os-ready-method", OsTemplateContents.OsReadyMethod, "Possible values: 'wait_for_ssh', 'wait_for_signal_from_os'. Default value: 'wait_for_ssh'."),
		"os_asset_id_bootloader_local_install_id_or_name": createTemplateCommand.FlagSet.String("install-bootloader-asset", command.NilDefaultStr, "Template's bootloader asset id during install"),
		"os_asset_id_bootloader_os_boot_id_or_name":       createTemplateCommand.FlagSet.String("os-boot-bootloader-asset", command.NilDefaultStr, "Template's bootloader asset id during regular server boot"),
		"version":                    createTemplateCommand.FlagSet.String("version", command.NilDefaultStr, "Template version. Default value is 0.0.0"),
		"network_os":                 createTemplateCommand.FlagSet.Bool("network-os", OsTemplateContents.NetworkOs, "Must be set for network operating system (NOS) templates. Default value is false"),
		"network_os_switch_driver":   createTemplateCommand.FlagSet.String("network-os-switch-driver", repoTemplate.NosSwitchDriver, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) switch driver, e.g. 'sonic_enterprise'."),
		"network_os_switch_role":     createTemplateCommand.FlagSet.String("network-os-switch-role", repoTemplate.NosSwitchRole, colors.Yellow("(Flag)")+"Network operating system (NOS) switch role. Possible values: 'leaf', 'spine'."),
		"network_os_datacenter_name": createTemplateCommand.FlagSet.String("network-os-datacenter-name", repoTemplate.NosDatacenterName, colors.Yellow("(Flag)")+"Network operating system (NOS) datacenter name, e.g. 'dc1'"),
		"network_os_version":         createTemplateCommand.FlagSet.String("network-os-version", repoTemplate.NosVersion, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) version, e.g. '4.0.2'"),
		"network_os_architecture":    createTemplateCommand.FlagSet.String("network-os-architecture", repoTemplate.NosArchitecture, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) architecture. Possible values: 'x86_64', 'aarch64'."),
		"network_os_vendor":          createTemplateCommand.FlagSet.String("network-os-vendor", repoTemplate.NosVendor, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) vendor, e.g. 'dellemc'"),
		"network_os_machine":         createTemplateCommand.FlagSet.String("network-os-machine", repoTemplate.NosMachine, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) machine(equipment model) e.g.'s5212f_c3538'"),
	}

	_, createError := templateCreateCmd(&createTemplateCommand, client)

	if createError != nil {
		updateTemplateCommand := command.Command{
			Description:  "Edit a template.",
			Subject:      "os-template",
			AltSubject:   "template",
			Predicate:    "update",
			AltPredicate: "edit",
			FlagSet:      flag.NewFlagSet("update template", flag.ExitOnError),
			ExecuteFunc:  templateEditCmd,
			Endpoint:     configuration.ExtendedEndpoint,
		}

		updateTemplateCommand.Arguments = map[string]interface{}{
			"template_id_or_name":                updateTemplateCommand.FlagSet.String("id", templateLabel, colors.Red("(Required)")+" Template's id or label"),
			"label":                              updateTemplateCommand.FlagSet.String("label", templateLabel, colors.Red("(Required)")+" Template's label"),
			"display_name":                       updateTemplateCommand.FlagSet.String("display-name", templateName, colors.Red("(Required)")+" Template's display name"),
			"size":                               updateTemplateCommand.FlagSet.Int("size", command.NilDefaultInt, "Template's size (bytes)"),
			"boot_methods_supported":             updateTemplateCommand.FlagSet.String("boot-methods-supported", OsTemplateContents.BootMethodsSupported, colors.Red("(Required)")+" Template boot methods supported. Defaults to pxe_iscsi."),
			"os_bootstrap_function_name":         updateTemplateCommand.FlagSet.String("os-bootstrap-function-name", command.NilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
			"boot_type":                          updateTemplateCommand.FlagSet.String("boot-type", OsTemplateContents.BootType, colors.Red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
			"description":                        updateTemplateCommand.FlagSet.String("description", templateDescription, "Template description"),
			"os_type":                            updateTemplateCommand.FlagSet.String("os-type", repoTemplate.Type, colors.Red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
			"os_version":                         updateTemplateCommand.FlagSet.String("os-version", repoTemplate.Version, colors.Red("(Required)")+" Template operating system version."),
			"os_architecture":                    updateTemplateCommand.FlagSet.String("os-architecture", repoTemplate.Architecture, colors.Red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
			"initial_user":                       updateTemplateCommand.FlagSet.String("initial-user", OsTemplateContents.InitialUser, colors.Red("(Required)")+" Template's initial username, used to verify install."),
			"initial_password":                   updateTemplateCommand.FlagSet.String("initial-password", command.NilDefaultStr, colors.Red("(Required)")+" Template's initial password, used to verify install."),
			"use_autogenerated_initial_password": updateTemplateCommand.FlagSet.Bool("use-autogenerated-initial-password", OsTemplateContents.UseAutogeneratedInitialPassword, colors.Green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used withinitial-password and initial-user params."),
			"initial_ssh_port":                   updateTemplateCommand.FlagSet.Int("initial-ssh-port", OsTemplateContents.InitialSSHPort, colors.Red("(Required)")+" Template's initial ssh port, used to verify install."),
			"change_password_after_deploy":       updateTemplateCommand.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
			"image_build_required":               updateTemplateCommand.FlagSet.Bool("image-build-required", OsTemplateContents.ImageBuildRequired, colors.Green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
			"provision_via_oob":                  updateTemplateCommand.FlagSet.Bool("provision-via-oob", OsTemplateContents.ProvisionViaOob, colors.Green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
			"repo_url":                           updateTemplateCommand.FlagSet.String("repo-url", command.NilDefaultStr, "Template's location the repository"),
			"network_os":                         updateTemplateCommand.FlagSet.Bool("network-os", OsTemplateContents.NetworkOs, "Must be set for network operating system (NOS) templates. Default value is false"),
			"network_os_switch_driver":           updateTemplateCommand.FlagSet.String("network-os-switch-driver", repoTemplate.NosSwitchDriver, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) switch driver, e.g. 'sonic_enterprise'."),
			"network_os_switch_role":             updateTemplateCommand.FlagSet.String("network-os-switch-role", repoTemplate.NosSwitchRole, colors.Yellow("(Flag)")+"Network operating system (NOS) switch role. Possible values: 'leaf', 'spine'."),
			"network_os_datacenter_name":         updateTemplateCommand.FlagSet.String("network-os-datacenter-name", repoTemplate.NosDatacenterName, colors.Yellow("(Flag)")+"Network operating system (NOS) datacenter name, e.g. 'dc1'"),
			"network_os_version":                 updateTemplateCommand.FlagSet.String("network-os-version", repoTemplate.NosVersion, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) version, e.g. '4.0.2'"),
			"network_os_architecture":            updateTemplateCommand.FlagSet.String("network-os-architecture", repoTemplate.NosArchitecture, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) architecture. Possible values: 'x86_64', 'aarch64'."),
			"network_os_vendor":                  updateTemplateCommand.FlagSet.String("network-os-vendor", repoTemplate.NosVendor, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) vendor, e.g. 'dellemc'"),
			"network_os_machine":                 updateTemplateCommand.FlagSet.String("network-os-machine", repoTemplate.NosMachine, colors.Yellow("(Required if network_os)")+"Network operating system (NOS) machine(equipment model) e.g.'s5212f_c3538'"),
		}

		_, updateError := templateEditCmd(&updateTemplateCommand, client)

		if updateError != nil {
			return "", updateError
		}

		list, err := client.OSTemplates()

		if err != nil {
			return "", err
		}

		templateFound := false

		for _, s := range *list {
			if s.VolumeTemplateLabel == templateLabel {
				templateFound = true
				break
			}
		}

		if !templateFound {
			return "", createError
		}
	}

	createAssetCommand := command.Command{
		Description:  "Create asset.",
		Subject:      "asset",
		AltSubject:   "asset",
		Predicate:    "create",
		AltPredicate: "new",
		ExecuteFunc:  osasset.AssetCreateCmd,
		Endpoint:     configuration.DeveloperEndpoint,
	}

	assets := []Asset{}

	err = createIsoImageAsset(c, repoTemplate, &assets, templateName, templateLabel, createAssetCommand)

	if err != nil {
		return "", err
	}

	err = createOtherAssets(c, repoTemplate, &assets, templateName, templateLabel, createAssetCommand)

	if err != nil {
		return "", err
	}

	for _, asset := range assets {
		if asset.Contents != "" {
			_, err = osasset.AssetCreateWithContentCmd(&asset.Command, client, []byte(asset.Contents))
		} else {
			_, err = osasset.AssetCreateCmd(&asset.Command, client)
		}

		if err != nil {
			fmt.Printf("Failed to upload asset %s. Received the following error: %s\n", asset.Name, err)
		} else {
			fmt.Printf("Uploaded asset %s.\n", asset.Name)
		}
	}

	return templateLabel, nil
}

func createIsoImageAsset(c *command.Command, repoTemplate RepoTemplate, assets *[]Asset, templateName string, templateLabel string, createAssetCommand command.Command) error {
	// Only OOB templates handle ISO image upload
	if !repoTemplate.OsTemplateContents.ProvisionViaOob {
		return nil
	}

	imageRepositoryHostname := defaultImageRepositoryHostname

	if userGivenImageRepositoryHostname := os.Getenv("METALCLOUD_IMAGE_REPOSITORY_HOSTNAME"); userGivenImageRepositoryHostname != "" {
		imageRepositoryHostname = os.Getenv("METALCLOUD_IMAGE_REPOSITORY_HOSTNAME")
	}

	imagePath, _ := command.GetStringParamOk(c.Arguments["source-iso"])

	// ISO upload is disabled for the moment
	originalImageFilenameArr := strings.Split(imagePath, "/")
	originalImageFilename := originalImageFilenameArr[len(originalImageFilenameArr)-1]
	imageFilename := strings.ReplaceAll(originalImageFilename, " ", "_")

	//isoPath := "/" + templateName + "-" + imageFilename
	isoPath := defaultImageRepositoryIsoPath + "/" + imageFilename

	_, err := handleIsoImageUpload(c, imageRepositoryHostname, isoPath, imagePath)

	if err != nil {
		return err
	}

	assetURL := "https://" + imageRepositoryHostname + isoPath

	createIsoCommand := createAssetCommand
	createIsoCommand.FlagSet = flag.NewFlagSet("create ISO asset", flag.ExitOnError)
	createIsoCommand.Arguments = map[string]interface{}{
		"filename":               createIsoCommand.FlagSet.String("filename", imageFilename, "Asset's filename"),
		"usage":                  createIsoCommand.FlagSet.String("usage", "build_source_image", "Asset's usage."),
		"mime":                   createIsoCommand.FlagSet.String("mime", assetMimeTypeBinary, "Asset's mime type. Possible values: \""+assetMimeTypeDynamic+"\", \""+assetMimeTypeBinary+"\""),
		"template_type":          createIsoCommand.FlagSet.String("template-type", assetTemplateTypeSimple, "Asset's template type. Possible values: \""+assetTemplateTypeNone+"\",\""+assetTemplateTypeSimple+"\", \""+assetTemplateTypeAdvanced+"\""),
		"url":                    createIsoCommand.FlagSet.String("url", assetURL, "Asset's source url. If present it will not read content anymore"),
		"read_content_from_pipe": createIsoCommand.FlagSet.Bool("pipe", false, "Read assets's content read from pipe instead of terminal input"),
		"template_id_or_name":    createIsoCommand.FlagSet.String("template-id", templateLabel, "Template's id or name to associate."),
		"path":                   createIsoCommand.FlagSet.String("path", "/source-image", "Path to associate asset to."),
		"variables_json":         createIsoCommand.FlagSet.String("variables-json", command.NilDefaultStr, "JSON encoded variables object"),
		"delete_if_exists":       createIsoCommand.FlagSet.Bool("delete-if-exists", true, "Automatically delete the existing asset associated with the current template."),
	}

	*assets = append(*assets, Asset{
		Name:    imageFilename,
		Command: createIsoCommand,
	})

	return nil
}

func handleIsoImageUpload(c *command.Command, imageRepositoryHostname string, isoPath string, imagePath string) (string, error) {
	remoteDirectoryPath := defaultImageRepositorySSHPath

	if userGivenRemoteDirectoryPath := os.Getenv("METALCLOUD_IMAGE_REPOSITORY_SSH_PATH"); userGivenRemoteDirectoryPath != "" {
		remoteDirectoryPath = os.Getenv("METALCLOUD_IMAGE_REPOSITORY_SSH_PATH")
	}

	remotePath := remoteDirectoryPath + isoPath

	remoteSSHPort := defaultImageRepositorySSHPort

	if userGivenSSHPort := os.Getenv("METALCLOUD_IMAGE_REPOSITORY_SSH_PORT"); userGivenSSHPort != "" {
		remoteSSHPort = os.Getenv("METALCLOUD_IMAGE_REPOSITORY_SSH_PORT")
	}

	imageRepositoryIsoPath := defaultImageRepositoryIsoPath

	if userGivenIsoPath := os.Getenv("METALCLOUD_IMAGE_REPOSITORY_ISO_PATH"); userGivenIsoPath != "" {
		imageRepositoryIsoPath = os.Getenv("METALCLOUD_IMAGE_REPOSITORY_ISO_PATH")
	}

	originalImagePath, _ := command.GetStringParamOk(c.Arguments["source-iso"])

	if !networking.CheckValidUrl(imagePath) {
		originalImageFilenameArr := strings.Split(originalImagePath, "/")
		originalImageFilename := originalImageFilenameArr[len(originalImageFilenameArr)-1]
		imageFilename := strings.ReplaceAll(originalImageFilename, " ", "_")

		remoteURL := "https://" + imageRepositoryHostname + imageRepositoryIsoPath

		fmt.Printf(colors.Green("Please upload ISO image %s to this path: %s\n"), originalImagePath, remoteURL+"/"+imageFilename)
		return "", nil

		if !command.GetBoolParam(c.Arguments["skip-upload-to-repo"]) {
			sshRepositoryHostname := imageRepositoryHostname + ":" + remoteSSHPort

			imageExists, err := networking.CheckRemoteFileExists(remoteURL, imageFilename)

			if err != nil {
				return "", err
			}

			if imageExists && !command.GetBoolParam(c.Arguments["replace-if-exists"]) {
				fmt.Printf("Image %s already exists at path %s. Skipping upload. Use the 'replace-if-exists' parameter to replace the existing image.\n", imageFilename, remotePath)
				return "", nil
			}

			if imageExists {
				fmt.Printf("Replacing image %s at path %s.\n", imageFilename, remotePath)
			} else {
				fmt.Printf("Uploading new image %s at path %s.\n", imageFilename, remotePath)
			}

			if userPrivateSSHKeyPath := os.Getenv("METALCLOUD_USER_PRIVATE_OPENSSH_KEY_PATH"); userPrivateSSHKeyPath == "" {
				return "", fmt.Errorf("METALCLOUD_USER_PRIVATE_OPENSSH_KEY_PATH must be set when creating an OS template. The key is needed when uploading to the ISO repository.")
			}

			userPrivateSSHKeyPath := os.Getenv("METALCLOUD_USER_PRIVATE_OPENSSH_KEY_PATH")

			homeDir, err := os.UserHomeDir()
			if err != nil {
				return "", err
			}

			var knownHostsFilePath string

			if userGivenHostsFilePath := os.Getenv("METALCLOUD_KNOWN_HOSTS_FILE_PATH"); userGivenHostsFilePath != "" {
				knownHostsFilePath = os.Getenv("METALCLOUD_KNOWN_HOSTS_FILE_PATH")
			} else {
				knownHostsFilePath = filepath.Join(homeDir, ".ssh", "known_hosts")

				// Create the known hosts file if it does not exist.
				if _, err := os.Stat(knownHostsFilePath); errors.Is(err, os.ErrNotExist) {
					hostsFile, err := os.Create(knownHostsFilePath)

					if err != nil {
						return "", err
					}

					hostsFile.Close()
				}
			}

			hostKeyCallback, err := kh.New(knownHostsFilePath)

			if err != nil {
				return "", fmt.Errorf("Received following error when parsing the known_hosts file: %s.", err)
			}

			// Use SSH key authentication from the auth package.
			clientConfig, err := auth.PrivateKey(
				"root",
				userPrivateSSHKeyPath,
				ssh.HostKeyCallback(func(hostname string, remoteAddress net.Addr, publicKey ssh.PublicKey) error {
					var keyError *kh.KeyError
					hostsError := hostKeyCallback(hostname, remoteAddress, publicKey)

					// Reference: https://www.godoc.org/golang.org/x/crypto/ssh/knownhosts#KeyError
					//if keyErr.Want is not empty and
					if errors.As(hostsError, &keyError) {
						if len(keyError.Want) > 0 {
							// If host is known then there is key mismatch and the connection is rejected.
							fmt.Printf(`
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The key sent by the remote host is
%s.
Please contact your system administrator.
Add correct host key in %s to get rid of this message.
Host key for %s has changed and you have requested strict checking.
Host key verification failed.
`,
								networking.SerializeSSHKey(publicKey), knownHostsFilePath, hostname,
							)
							return keyError
						} else {
							// If keyErr.Want slice is empty then host is unknown.
							fmt.Printf(`
The authenticity of host '%s' can't be established.
SSH key is %s.
This key is not known by any other names.
It will be added to known_hosts file %s.
Are you sure you want to continue connecting (yes/no)?
`,
								hostname, networking.SerializeSSHKey(publicKey), knownHostsFilePath,
							)

							if command.GetBoolParam(c.Arguments["skip-host-key-checking"]) {
								reader := bufio.NewReader(os.Stdin)
								input, err := reader.ReadString('\n')

								if err != nil {
									return err
								}

								// Remove \r and \n from input
								input = string(bytes.TrimSuffix([]byte(input), []byte("\r\n")))

								if input != "yes" {
									if input == "no" {
										fmt.Println("Aborting connection.")
									} else {
										fmt.Println("Invalid response given. Aborting connection.")
									}

									return keyError
								}
							} else {
								fmt.Printf("Skipped manual check because 'skip-host-key-checking' is set to false.")
							}

							return networking.AddHostKey(knownHostsFilePath, remoteAddress, publicKey)
						}
					}

					fmt.Printf("Public key exists for remote %s. Establishing connection.\n", hostname)
					return nil
				}),
			)

			if err != nil {
				return "", fmt.Errorf("Could not create SSH client config. Received error: %s", err)
			}

			// Create a new SCP client.
			scpClient := scp.NewClient(sshRepositoryHostname, &clientConfig)

			// Connect to the remote server.
			err = scpClient.Connect()
			if err != nil {
				return "", fmt.Errorf("Couldn't establish a connection to the remote server: %s", err)
			}

			defer scpClient.Close()

			fmt.Printf("Established connection to hostname %s.\n", sshRepositoryHostname)

			isoImagefile, err := os.Open(imagePath)
			if err != nil {
				return "", fmt.Errorf("Image not found at path %s.", imagePath)
			}
			defer isoImagefile.Close()

			fmt.Printf("Starting image upload to repository at path %s.\n", remotePath)
			err = scpClient.CopyFile(context.Background(), isoImagefile, remotePath, "0777")

			if err != nil {
				return "", fmt.Errorf("Error while copying file: %s", err)
			}

			fmt.Printf("Finished image upload to repository at path %s.\n", remotePath)

		} else {
			fmt.Printf("Skipped uploading image to repository at path %s.", remotePath)
		}
	}

	return "", nil
}

func createOtherAssets(c *command.Command, repoTemplate RepoTemplate, assets *[]Asset, templateName string, templateLabel string, createAssetCommand command.Command) error {
	if value, ok := command.GetStringParamOk(c.Arguments["assets-update"]); ok {
		assetsUpdateString := value

		// Format is: template_asset_1:/local_replace_asset_1,template_asset_2:/local_replace_asset_2
		assetParts := strings.Split(assetsUpdateString, ",")
		for _, assetPart := range assetParts {
			parts := strings.Split(assetPart, ":")

			if len(parts) != 2 {
				return fmt.Errorf("Invalid format detected for 'assets-update' parameter. Asset update parts must be separated by commas and each asset update part must have the name of the asset file which contents will be replaced, followed by ':' and the local path to the new asset. Check build command for an example.")
			}

			templateAssetName := parts[0]
			localAssetPath := parts[1]

			if _, ok := repoTemplate.Assets[templateAssetName]; !ok {
				return fmt.Errorf("Asset with name %s not found in the template.yaml file. Only assets found there can have their contents replaced.", templateAssetName)
			}

			localAssetFile, err := os.Open(localAssetPath)

			if err != nil {
				return fmt.Errorf("Asset file not found at path %s.", localAssetPath)
			}
			defer localAssetFile.Close()

			fileBytes, err := os.ReadFile(localAssetPath)
			asset := repoTemplate.Assets[templateAssetName]
			asset.contents = string(fileBytes)
			repoTemplate.Assets[templateAssetName] = asset
		}
	}

	imageRepositoryHostname := defaultImageRepositoryHostname

	if userGivenImageRepositoryHostname := os.Getenv("METALCLOUD_IMAGE_REPOSITORY_HOSTNAME"); userGivenImageRepositoryHostname != "" {
		imageRepositoryHostname = os.Getenv("METALCLOUD_IMAGE_REPOSITORY_HOSTNAME")
	}

	for _, asset := range repoTemplate.Assets {
		assetContents := asset.contents

		if asset.Usage == "" {
			asset.Usage = command.NilDefaultStr
		}

		var assetURL string

		if asset.Url == "" {
			assetURL = command.NilDefaultStr
		} else {
			assetURL = "https://" + imageRepositoryHostname + asset.Url
		}

		// For OOB templates, isopath is populated, for non-OOB ones, path is used instead.
		var assetPath string

		if repoTemplate.OsTemplateContents.ProvisionViaOob {
			assetPath = asset.Isopath
		} else {
			assetPath = asset.Path
		}

		createOtherAssetCommand := createAssetCommand
		createOtherAssetCommand.FlagSet = flag.NewFlagSet("create asset "+asset.name, flag.ExitOnError)
		createOtherAssetCommand.Arguments = map[string]interface{}{
			"filename":               createOtherAssetCommand.FlagSet.String("filename", asset.name, "Asset's filename"),
			"usage":                  createOtherAssetCommand.FlagSet.String("usage", asset.Usage, "Asset's usage."),
			"mime":                   createOtherAssetCommand.FlagSet.String("mime", asset.Mime, "Asset's mime type. Possible values: \""+assetMimeTypeDynamic+"\",\""+assetMimeTypeBinary+"\""),
			"template_type":          createOtherAssetCommand.FlagSet.String("template-type", asset.TemplateType, "Asset's template type. Possible values: \""+assetTemplateTypeNone+"\",\""+assetTemplateTypeSimple+"\", \""+assetTemplateTypeAdvanced+"\""),
			"url":                    createOtherAssetCommand.FlagSet.String("url", assetURL, "Asset's source url. If present it will not read content anymore"),
			"read_content_from_pipe": createOtherAssetCommand.FlagSet.Bool("pipe", false, "Read assets's content read from pipe instead of terminal input"),
			"template_id_or_name":    createOtherAssetCommand.FlagSet.String("template-id", templateLabel, "Template's id or name to associate. "),
			"path":                   createOtherAssetCommand.FlagSet.String("path", assetPath, "Path to associate asset to."),
			"variables_json":         createOtherAssetCommand.FlagSet.String("variables-json", command.NilDefaultStr, "JSON encoded variables object"),
			"delete_if_exists":       createOtherAssetCommand.FlagSet.Bool("delete-if-exists", true, "Automatically delete the existing asset associated with the current template."),
		}

		*assets = append(*assets, Asset{
			Name:     asset.name,
			Command:  createOtherAssetCommand,
			Contents: assetContents,
		})
	}

	return nil
}

func templateDiffCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {
	var filePath1, filePath2, outputFilePath string

	if file1, ok := command.GetStringParamOk(c.Arguments["file1"]); ok {
		filePath1 = file1
	} else {
		return "", fmt.Errorf("Did not find the 'file1' parameter.")
	}

	if file2, ok := command.GetStringParamOk(c.Arguments["file2"]); ok {
		filePath2 = file2
	} else {
		return "", fmt.Errorf("Did not find the 'file2' parameter.")
	}

	if outputFile, ok := command.GetStringParamOk(c.Arguments["output-file"]); ok {
		outputFilePath = outputFile
	} else {
		return "", fmt.Errorf("Did not find the 'output-file' parameter.")
	}

	fileContents1, err := os.ReadFile(filePath1)

	if err != nil {
		return "", err
	}

	fileContents2, err := os.ReadFile(filePath2)

	if err != nil {
		return "", err
	}

	diffMatchPatch := diff.New()

	diffs := diffMatchPatch.DiffMain(string(fileContents1), string(fileContents2), false)
	patches := diffMatchPatch.PatchMake(diffs)
	patchText := diffMatchPatch.PatchToText(patches)

	file, err := os.Create(outputFilePath)

	if err != nil {
		return "", nil
	}
	defer file.Close()

	writer := bufio.NewWriter(file)

	_, err = fmt.Fprintf(writer, "%s", patchText)
	if err != nil {
		return "", nil
	}

	writer.Flush()
	return "", nil
}

func templateListRepoCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {
	repoMap := make(map[string]RepoTemplate)
	err := retrieveRepositoryAssets(c, repoMap)

	if err != nil {
		return "", err
	}

	table := createRepositoryTemplatesTable(repoMap)
	return table.RenderTable("Repository templates", "", command.GetStringParam(c.Arguments["format"]))
}

func templateListAssetsCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {
	var sourceTemplate string

	if sourceTemplateValue, ok := command.GetStringParamOk(c.Arguments["source-template"]); !ok {
		return "", fmt.Errorf("The 'source-template' parameter must be specified when using the 'list-source-template-assets' command.")
	} else {
		sourceTemplate = sourceTemplateValue
	}

	useLocalTemplate := false

	if repoValue, ok := command.GetStringParamOk(c.Arguments["repo"]); ok {
		if repoValue == localRepositoryName {
			useLocalTemplate = true
		}
	}

	var table tableformatter.Table

	if !useLocalTemplate {
		repoMap := make(map[string]RepoTemplate)
		err := retrieveRepositoryAssets(c, repoMap)

		if err != nil {
			return "", err
		}

		if _, ok := repoMap[sourceTemplate]; !ok {
			return "", fmt.Errorf("Did not find source template '%s' in the repository.", sourceTemplate)
		}

		table = createTemplateAssetsTable(repoMap[sourceTemplate])
	} else {
		_, err := os.ReadFile(sourceTemplate)

		if err != nil {
			return "", fmt.Errorf("Template file not found at path %s.", sourceTemplate)
		}

		repoTemplate := RepoTemplate{}

		getLocalTemplateAssets(filepath.Dir(sourceTemplate), &repoTemplate)
		templateHasErrors, err := populateTemplateValues(&repoTemplate)

		if err != nil {
			return "", err
		}

		if templateHasErrors {
			fmt.Printf("Found errors for template file %s! Use the 'validate-template' function to see them and fix them.\n", sourceTemplate)
		}

		table = createTemplateAssetsTable(repoTemplate)
	}

	return table.RenderTable("Template assets", "", command.GetStringParam(c.Arguments["format"]))
}

func templateValidateRepoCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {
	repoMap := make(map[string]RepoTemplate)
	err := retrieveRepositoryAssets(c, repoMap)

	if err != nil {
		return "", err
	}

	for templatePrefix, repoTemplate := range repoMap {
		if len(repoTemplate.Errors) != 0 {
			fmt.Printf("Detected the following errors regarding repository structure for template %s:\n", templatePrefix)
		}

		for _, errorMessage := range repoTemplate.Errors {
			fmt.Println("\t" + errorMessage)
		}
	}

	return "", err
}

func templateValidateCmd(c *command.Command, client metalcloud.MetalCloudClient) (string, error) {
	var sourceTemplate string

	if sourceTemplateValue, ok := command.GetStringParamOk(c.Arguments["source-template"]); !ok {
		return "", fmt.Errorf("The 'source-template' parameter must be specified when using the 'validate-template' command.")
	} else {
		sourceTemplate = sourceTemplateValue
	}

	useLocalTemplate := false

	if repoValue, ok := command.GetStringParamOk(c.Arguments["repo"]); ok {
		if repoValue == localRepositoryName {
			useLocalTemplate = true
		}
	}

	var repoTemplate RepoTemplate

	if !useLocalTemplate {
		repoMap := make(map[string]RepoTemplate)
		err := retrieveRepositoryAssets(c, repoMap)

		if err != nil {
			return "", err
		}

		if _, ok := repoMap[sourceTemplate]; !ok {
			return "", fmt.Errorf("Did not find source template '%s' in the repository.", sourceTemplate)
		}

		repoTemplate = repoMap[sourceTemplate]
	} else {
		fmt.Printf("Did not find source template '%s' in the repository, checking for local file.\n", sourceTemplate)

		_, err := os.ReadFile(sourceTemplate)

		if err != nil {
			return "", fmt.Errorf("Template file not found at path %s.", sourceTemplate)
		}

		err = getLocalTemplateAssets(filepath.Dir(sourceTemplate), &repoTemplate)
		if err != nil {
			return "", err
		}

		_, err = populateTemplateValues(&repoTemplate)

		if err != nil {
			return "", err
		}
	}

	if len(repoTemplate.Errors) != 0 {
		fmt.Printf("Detected the following errors regarding template structure for template %s:\n", sourceTemplate)
	} else {
		fmt.Printf("Detected no errors for the given template.\n")
	}

	for _, errorMessage := range repoTemplate.Errors {
		fmt.Println("\t" + errorMessage)
	}

	return "", nil
}

func stringInSlice(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

func sliceDifference(slice1 []string, slice2 []string) []string {
	var diff []string

	for _, s1 := range slice1 {
		found := false

		for _, s2 := range slice2 {
			if s1 == s2 {
				found = true
				break
			}
		}

		if !found {
			diff = append(diff, s1)
		}
	}

	return diff
}

func getRepositoryTemplateAssets(tree *object.Tree, repoMap map[string]RepoTemplate, repoAssetsPerTemplate map[string][]TemplateAsset) {
	files := tree.Files()
	files.ForEach(func(file *object.File) error {
		if file.Mode.IsRegular() {
			if strings.Count(file.Name, "/") == 3 {
				parts := strings.Split(file.Name, "/")
				templatePrefix := strings.Join(parts[:3], "/")

				fileContents, err := file.Contents()

				if err != nil {
					return err
				}

				if parts[3] == templateFileName {
					if _, ok := repoMap[templatePrefix]; !ok {
						repoMap[templatePrefix] = RepoTemplate{
							SourcePath:           templatePrefix,
							TemplateFileContents: fileContents,
						}
					}
				} else if parts[3] != readMeFileName {
					asset := TemplateAsset{
						name:     parts[3],
						contents: fileContents,
					}

					repoAssetsPerTemplate[templatePrefix] = append(repoAssetsPerTemplate[templatePrefix], asset)
				}
			}
		}

		return nil
	})
}

func getLocalTemplateAssets(dirName string, repoTemplate *RepoTemplate) error {
	f, err := os.Open(dirName)

	if err != nil {
		return err
	}

	files, err := f.Readdir(-1)
	f.Close()
	if err != nil {
		return err
	}

	repoAssets := []TemplateAsset{}
	for _, file := range files {
		if file.IsDir() || file.Name() == readMeFileName {
			continue
		}

		fileBytes, err := os.ReadFile(file.Name())

		if err != nil {
			return err
		}

		fileContents := string(fileBytes)

		if file.Name() == templateFileName {
			repoTemplate.SourcePath = templateFileName
			repoTemplate.TemplateFileContents = fileContents
		} else {
			asset := TemplateAsset{
				name:     file.Name(),
				contents: fileContents,
			}

			repoAssets = append(repoAssets, asset)
		}
	}

	repoTemplate.Assets = make(map[string]TemplateAsset)
	for _, asset := range repoAssets {
		repoTemplate.Assets[asset.name] = asset
	}

	return nil
}

func populateTemplateValues(repoTemplate *RepoTemplate) (bool, error) {
	templateHasErrors := false
	templateStringContents := repoTemplate.TemplateFileContents

	var templateContents TemplateContents
	err := yaml.Unmarshal([]byte(templateStringContents), &templateContents)

	if err != nil {
		return templateHasErrors, err
	}

	repoTemplate.OsTemplateContents = templateContents.OsTemplateContents

	var architecture string
	var osType string
	var version string
	var nosArchitecture string
	var nosVersion string
	var nosDatacenterName string
	var nosVendor string
	var nosMachine string
	var nosSwitchDriver string
	var nosSwitchRole string

	if templateContents.OsTemplateContents.NetworkOs {
		nosArchitecture = templateContents.OsTemplateContents.NetworkOsArchitecture
		nosVersion = templateContents.OsTemplateContents.NetworkOsVersion
		if templateContents.OsTemplateContents.NetworkOsDatacenterName != "" {
			nosDatacenterName = templateContents.OsTemplateContents.NetworkOsDatacenterName
		}
		nosVendor = templateContents.OsTemplateContents.NetworkOsVendor
		nosMachine = templateContents.OsTemplateContents.NetworkOsSwitchDriver
		nosSwitchDriver = templateContents.OsTemplateContents.NetworkOsSwitchDriver
		if templateContents.OsTemplateContents.NetworkOsSwitchRole != "" {
			nosSwitchRole = templateContents.OsTemplateContents.NetworkOsSwitchRole
		}
	} else {
		architecture = templateContents.OsTemplateContents.OsArchitecture
		osType = templateContents.OsTemplateContents.OsType
		version = templateContents.OsTemplateContents.OsVersion
	}

	var deployProcess string

	if templateContents.OsTemplateContents.ProvisionViaOob {
		deployProcess = oobDeployProcess
	} else {
		deployProcess = pxeDeployProcess
	}
	bootType := templateContents.OsTemplateContents.BootType

	validArchitectures := []string{osArchitecture64}
	validDeployProcesses := []string{oobDeployProcess, pxeDeployProcess}
	validBootTypes := []string{bootTypeUEFIOnly, bootTypeLegacyOnly}
	validMimeTypes := []string{assetMimeTypeBinary, assetMimeTypeDynamic}
	validTemplateTypes := []string{assetTemplateTypeNone, assetTemplateTypeSimple, assetTemplateTypeAdvanced}
	validAssetTypes := []string{assetTypeBootloader, assetTypeBootloaderConfig, assetTypeInstallerConfig, assetTypePatch, assetTypeOther}
	validUsageType := []string{assetUsageTypeBootloader, assetUsageTypeBuildComponent}
	validNosSwitchRole := []string{nosSwitchRoleLeaf, nosSwitchRoleSpine, nosSwitchRoleNone}
	validNosSwitchDriver := []string{"sonic_enterprise", "hp5800", "hp5900", "cumulus42", "cisco_aci51", "dummy"}

	errors := []string{}

	if templateContents.OsTemplateContents.NetworkOs {
		if nosArchitecture == "" {
			errors = append(errors, fmt.Sprintf("Found no OS architecture. There must be one in the os-template section with the key name 'network-os-architecture'. Valid architectures are %+q.", validArchitectures))
		} else if !stringInSlice(nosArchitecture, validArchitectures) {
			errors = append(errors, fmt.Sprintf("Found invalid architecture %s. Valid architectures are %+q.", nosArchitecture, validArchitectures))
		}

		if nosVersion == "" {
			errors = append(errors, fmt.Sprintf("Found no NOS version. There must be one in the os-template section with the key name 'network-os-version'."))
		}

		if nosVendor == "" {
			errors = append(errors, fmt.Sprintf("Found no NOS vendor. There must be one in the os-template section with the key name 'network-os-vendor'."))
		}

		if nosMachine == "" {
			errors = append(errors, fmt.Sprintf("Found no NOS machine. There must be one in the os-template section with the key name 'network-os-machine'."))
		}

		if nosSwitchDriver == "" {
			errors = append(errors, fmt.Sprintf("Found no NOS switch driver. There must be one in the os-template section with the key name 'network-os-switch-driver'."))
		} else if !stringInSlice(nosSwitchDriver, validNosSwitchDriver) {
			errors = append(errors, fmt.Sprintf("Found invalid NOS switch driver %s. Valid NOS switch drivers are %+q.", nosSwitchDriver, validNosSwitchDriver))
		}

		if !stringInSlice(nosSwitchRole, validNosSwitchRole) {
			errors = append(errors, fmt.Sprintf("Found invalid NOS switch role %s. Valid NOS switch roles are %+q.", nosSwitchRole, validNosSwitchRole))
		}

	} else {
		if osType == "" {
			errors = append(errors, fmt.Sprintf("Found no OS type. There must be one in the os-template section with the key name 'os-type'."))
		}

		if version == "" {
			errors = append(errors, fmt.Sprintf("Found no OS version. There must be one in the os-template section with the key name 'os-version'."))
		}

		if architecture == "" {
			errors = append(errors, fmt.Sprintf("Found no OS architecture. There must be one in the os-template section with the key name 'os-architecture'. Valid architectures are %+q.", validArchitectures))
		} else if !stringInSlice(architecture, validArchitectures) {
			errors = append(errors, fmt.Sprintf("Found invalid architecture %s. Valid architectures are %+q.", architecture, validArchitectures))
		}

		if bootType == "" {
			errors = append(errors, fmt.Sprintf("Found no boot type. There must be one in the os-template section with the key name 'boot-type'. Valid boot types are %+q.", validBootTypes))
		} else if !stringInSlice(bootType, validBootTypes) {
			errors = append(errors, fmt.Sprintf("Found invalid boot type %s. Valid boot types are %+q.", bootType, validBootTypes))
		}
	}

	if deployProcess == "" {
		errors = append(errors, fmt.Sprintf("Found no deploy process. There must be one in the os-template section with the key name 'boot-methods-supported'. Valid boot methods are %+q.", validDeployProcesses))
	} else if !stringInSlice(deployProcess, validDeployProcesses) {
		errors = append(errors, fmt.Sprintf("Found invalid boot method %s. Valid boot methods are %+q.", deployProcess, validDeployProcesses))
	}

	var repoFileNames, templateFileNames []string

	for assetName, asset := range repoTemplate.Assets {
		assetContents := asset.contents

		// We ignore the ReadMe file
		if assetName == readMeFileName {
			continue
		}
		repoFileNames = append(repoFileNames, assetName)

		if asset, ok := templateContents.Assets[assetName]; ok {
			if asset.Mime == "" {
				errors = append(errors, fmt.Sprintf("Found no mime type for asset %s. There must be one for the asset with the key name 'mime'. Valid mime types are %+q.", assetName, validMimeTypes))
			} else if !stringInSlice(asset.Mime, validMimeTypes) {
				errors = append(errors, fmt.Sprintf("Found invalid mime type %s for asset %s. Valid mime types are %+q.", asset.Mime, assetName, validMimeTypes))
			}

			if asset.TemplateType == "" {
				errors = append(errors, fmt.Sprintf("Found no template type for asset %s. There must be one for the asset with the key name 'template-type'. Valid asset template types are %+q.", assetName, validTemplateTypes))
			} else if !stringInSlice(asset.TemplateType, validTemplateTypes) {
				errors = append(errors, fmt.Sprintf("Found invalid template type %s for asset %s. Valid asset template types are %+q.", asset.TemplateType, assetName, validTemplateTypes))
			}

			if asset.Type == "" {
				errors = append(errors, fmt.Sprintf("Found no asset type for asset %s. There must be one for the asset with the key name 'type'. Valid asset types are %+q.", assetName, validAssetTypes))
			} else if !stringInSlice(asset.Type, validAssetTypes) {
				errors = append(errors, fmt.Sprintf("Found invalid asset type %v for asset %s. Valid asset types are %+q.", asset.Type, assetName, validAssetTypes))
			}

			if asset.Usage != "" && !stringInSlice(asset.Usage, validUsageType) {
				errors = append(errors, fmt.Sprintf("Found invalid usage type %v for asset %s. Property is not required and the valid usage types are %+q.", asset.Usage, assetName, validUsageType))
			}

			// For OOB templates, isopath is populated, for non-OOB ones, path is used instead.
			if repoTemplate.OsTemplateContents.ProvisionViaOob {
				if asset.Isopath == "" {
					errors = append(errors, fmt.Sprintf("Found no isopath for asset %s. There must be one for the asset with the key name 'isopath', as the asset is part of an OOB template.", assetName))
				}
			} else if asset.Path == "" {
				errors = append(errors, fmt.Sprintf("Found no path for asset %s. There must be one for the asset with the key name 'path', as the asset is part of a non-OOB template.", assetName))
			}

			asset.name = assetName
			asset.contents = assetContents
			repoTemplate.Assets[assetName] = asset
		}
	}

	// Add the assets that are part of non-OOB templates and are not physically in the repository.
	if !repoTemplate.OsTemplateContents.ProvisionViaOob {
		for assetName, asset := range templateContents.Assets {
			if asset.Url != "" {
				if asset.Path == "" {
					errors = append(errors, fmt.Sprintf("Found no path for asset %s. There must be one for the asset with the key name 'path', as the asset is part of a non-OOB template.", assetName))
				}

				asset.name = assetName
				repoTemplate.Assets[assetName] = asset
			}
		}
	}

	for assetName, asset := range templateContents.Assets {
		// We ignore files that have an URL, since they don't need to be in the repository.
		if asset.Url != "" {
			continue
		}
		templateFileNames = append(templateFileNames, assetName)
	}

	fileNamesNotInTemplate := sliceDifference(repoFileNames, templateFileNames)
	fileNamesNotInRepository := sliceDifference(templateFileNames, repoFileNames)

	if len(fileNamesNotInTemplate) != 0 {
		errors = append(errors, fmt.Sprintf("Found the following repository files that are not in the %s file: %+q.", templateFileName, fileNamesNotInTemplate))
	}

	if len(fileNamesNotInRepository) != 0 {
		errors = append(errors, fmt.Sprintf("Found the following files declared in %s that are not in the repository: %+q.", templateFileName, fileNamesNotInRepository))
	}

	repoTemplate.Errors = errors

	if len(errors) != 0 {
		templateHasErrors = true
	}

	if templateContents.OsTemplateContents.NetworkOs {
		repoTemplate.NosArchitecture = nosArchitecture
		repoTemplate.NosVersion = nosVersion
		repoTemplate.NosDatacenterName = nosDatacenterName
		repoTemplate.NosVendor = nosVendor
		repoTemplate.NosMachine = nosMachine
		repoTemplate.NosSwitchDriver = nosSwitchDriver
		repoTemplate.NosSwitchRole = nosSwitchRole
		repoTemplate.BootType = bootType
	} else {
		repoTemplate.Architecture = architecture
		repoTemplate.DeployProcess = deployProcess
		repoTemplate.BootType = bootType
		repoTemplate.Type = osType
		repoTemplate.Version = version
	}

	return templateHasErrors, err
}
